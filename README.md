# 동시성 제어 방식에 대한 분석 및 보고서 작성

> ### [상황 가정]   
> 1. 분산 환경은 고려하지 않는다  
> 2. 동시에 여러 요청이 들어오더라도 순서대로 제어되어야한다 

## 동시성 문제가 발생할 수 있는 상황 예상 시나리오
1. 유저가 동시에 충전하는 경우
   #### 첫번째 충전(요청)후 유저 포인트가 업데이트 되기전 조회하여 덮어씌어지는 경우 
   ```
   Thread-1 : 유저A 1000원 충전 요청
   Thread-2 : 유저A 1000원 충전 요청
   
   Thread-1 : 유저A 현재 포인트 조회 - 1000원
   Thread-2 : 유저A 현재 포인트 조회 - 1000원
   
   Thread-1 : 유저A 포인트 충전 - 2000원으로 업데이트
   Thread-2 : 유저A 포인트 충전 - 2000원으로 업데이트 (최종)
   
   정상 처리시 현재 유저A 잔여 포인트 4000원이어야함  
   ```
2. 유저가 동시에 사용하는 경우
   #### 첫번째 사용(요청)후 유저 포인트가 업데이트 되기전 조회하여 덮어씌어지는 경우
   ```
   Thread-1 : 유저A 1000원 사용 요청
   Thread-2 : 유저A 1000원 사용 요청
   
   Thread-1 : 유저A 현재 포인트 조회 - 5000원
   Thread-2 : 유저A 현재 포인트 조회 - 5000원
   
   Thread-1 : 유저A 포인트 사용 - 4000원으로 업데이트
   Thread-2 : 유저A 포인트 사용 - 4000원으로 업데이트 (최종)

   정상 처리시 현재 유저A 잔여 포인트 3000원이어야함
   ```
3. 유저가 동시에 여러 요청을 보내는 경우
   #### 첫번째 요청(충전 or 사용)후 유저 포인트가 업데이트 되기전 조회하여 덮어씌어지는 경우
   ```
   Thread-1 : 유저A 1000원 충전 요청
   Thread-2 : 유저A 1000원 사용 요청
   
   Thread-1 : 유저A 현재 포인트 조회 - 5000원
   Thread-2 : 유저A 현재 포인트 조회 - 5000원
   
   Thread-1 : 유저A 포인트 충전 - 6000원으로 업데이트
   Thread-2 : 유저A 포인트 사용 - 4000원으로 업데이트 (최종)

   정상 처리시 현재 유저A 잔여 포인트 5000원이어야함
   ```
   #### 첫번째 요청(충전 or 사용)후 유저 포인트를 조회하는 경우
   ```
   Thread-1 : 유저A 1000원 충전 요청
   Thread-2 : 유저A 포인트 조회 요청
   
   Thread-1 : 유저A 현재 포인트 조회 - 5000원
   Thread-2 : 유저A 현재 포인트 조회 - 5000원 -> 응답 
   
   Thread-1 : 유저A 포인트 충전 - 6000원으로 업데이트

   정상 처리시 현재 유저A 포인트 6000원으로 응답해주어야함
   ```
   #### 첫번째 요청(충전 or 사용)후 유저 포인트 변경 내역을 조회하는 경우
   ```
   #### 현재 포인트 변경 내역 없다고 가정 ####
   
   Thread-1 : 유저A 1000원 충전 요청
   Thread-2 : 유저A 포인트 변경 내역 조회 요청
   
   Thread-1 : 유저A 현재 포인트 조회 - 0원
   Thread-2 : 유저A 포인트 변경 내역 조회 - 내역 없음 -> 응답
   
   Thread-1 : 유저A 포인트 충전 - 1000원으로 업데이트
   Thread-1 : 유저A 포인트 변경 내역 추가

   정상 처리시 현재 유저A 1000원 충전 내역을 응답해주어야함
   ```

## 동시성 문제 제어 방식 분석 및 결정

> 1. 현재 실제 DB 연동을 하지않기에 DB레벨의 락방식은 고려하지 않음  
> 2. PointHistoryTable, UserPointTable 클래스는 변경하지않는다는 요구사항 

### 고려한 동시성 제어 방식
1. synchronized 키워드 
   - 시나리오: 동시성 문제가 발생할 수 있는 메서드 또는 코드 블록에 synchronized 키워드 사용하여 락 획득
   - 장점: 
     - 간단하게 적용 가능
   - 단점: 
     - 전역적으로 락을 걸기때문에 병목 발생가능성 높음
     - 개별 사용자별로 락을 적용하기 까다로움
2. ReentrantLock 
   - 시나리오: 사용자별로 ReentrantLock을 생성하여 락 획득
   - 장점:
     - 사용자별로 락을 관리하여 같은 사용자의 요청만 순차적으로 처리가 보장되고  
      다른 사용자의 요청을 병렬 처리 가능
     - synchronized 방식보다 유연하게 제어 가능
   - 단점:
     - 락 객체를 별도로 정리 해야함
     - ReentrantLock 객체를 저장할 수 있는 자료구조가 필요함
3. ConcurrentHashMap + compute 등 원자적 연산 수행
   - 시나리오: ConcurrentHashMap에 사용자별 포인트를 관리하고 원자적 연산 수행
   - 장점: 
     - 높은 동시성 성능 제공
     - 원자적으로 수행하여 읽기, 수정, 쓰기연산의 경쟁 조건을 안전하게 처리할 수 있음
   - 단점:
     - 간단한 값 업데이트는 효과적이지만 여러 단계를 거치는 트랜잭션은 원자적으로 처리하기 어려움
     - 비즈니스 로직이 복잡해질수록 compute안에 담기에 가독성과 유지보수성이 떨어짐

### 동시성 제어 방식 결정: ReentrantLock

- 선택이유:
  - synchronized 
    - 키워드는 해당 메서드나 코드블록이 전역적으로 동기화함으로 병목가능성이 매우 높음
    - 개별 사용자간의 락을 관리하기 까다로움
  - ConcurrentHashMap + compute 
    - 여러 트랜잭션들을 원자적으로 처리하기 어렵다는 점 (UserPointTable 수정 -> PointHistoryTable 입력)

ReentrantLock 방식이 단점에 비해 장점이 더 크다고 생각되고 다른 방식들의 단점을 모두 커버할수있음
따라서 해당 방식이 가장 적합하다고 판단된다.
